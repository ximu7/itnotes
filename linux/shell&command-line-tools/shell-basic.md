[TOC]

# 简介

Shell 是一个用 C 语言编写的程序，Shell 既是一种命令语言，又是一种程序设计语言。Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。

Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。

**Shell 脚本（shell script）**，是一种为 shell 编写的脚本程序。

**Shell环境**:运行shell脚本的环境。

shell分类：

 - Bourne：常见的是sh(Bourne Shell)和bash(Bourne Again Shell)，还有fish、zsh等等
 - C：cshell、tcsh（BSD的Unix)

以下以bash为默认shell。

- shell查看

```shell
echo $SHELL    #查看当前使用的shell
cat /etc/shells    #查看当前系统支持的shell
```

- 扩展名sh：脚本文件**可以不使用扩展名** （但是使用扩展名sh，shell可以为代码提供颜色高亮）。

- 解释器：在脚本文件开始时使用类似`#!/bin/sh`指定解释器。

- 执行脚本

  - 脚本需要有执行权限：`chmod +x file`
  - 运行方法：`./file.sh`或`bash file.sh`

- 命令别名alias

  示例：`alias ll='ls -al --color=auto'`  使用ll别名替代`ls -al --color=auto`这条命令，仅临时生效。可以在`~/.bashr`中使用alias设置别名，使得该别名在当前用户下一直生效。添加别名后，使用`source ~/.bashrc`可使其立即生效。

- 命令优先级顺序：绝对/相对路径执行命令>**别名>bash内部命令>**$PATH环境变量定义的目录查找顺序的第一个命令

# 基础

## 基本特殊符号

- ``：反引号，反引号内部的内容是系统命令，会最先执行。

- `$()`：和反引号作用一样，只是反引号中对`\`进行了转义，而`$()`中没有。

- `~`： 表示当前执行用户的家目录。

- / ：斜杠，路径分隔符。

- \：反斜杠，转义符，将后一个特殊字符转为普通字符。

- 引号

  - 单引号`''`：引号内特殊字符均无特殊意义。
  - 双引号`""`： 引号中除了`$ \ ""  （反引号、美元符号、反斜杠和双引号）外，特殊字符均无特殊意义。

  注意：特殊字符\无特殊意义进指的\本身，不包括\与其他字符组合的控制符（如\n）。

- `#`：注释符号。

- `()`：子命令组，另开一个子shell顺序执行，其中的变量不能够被外面部分使用。

- `&`：将命令放入后台执行。

上述特殊字符与其他字符组合成的特殊意义（如\加上一些字符成为特殊意义的[控制符](#控制符) ），以及其余特殊符号，归入后文各相关章节叙述。

## 多命令执行符号

### 逻辑符

- `; `  分号-- `a;b`   各命令间没有逻辑关系影响
- `&& `   逻辑与--`a&&b`    前面的命令正确执行，才能执行后面的命令
- `||`    逻辑或--`a||b`    前面的命令不能正确执行，就执行后面的命令

### 管道符

`|`  -- `a|b`    前面命令的**正确输出**作为命令B的操作对象。

## 通配符

- `?`    匹配1个字符
- `*`    匹配任意个数字符
- `[]`    匹配括号内任意一个字符（如`[ab]`匹配a或b或c）
  - `[-]`   匹配在编码顺序内的所有字符（如`[a-z]`匹配a到z的字母）
  - `[!]`    匹配**除了**`!`后面字符的其他字符（如`[!abc]`匹配除了abc的字符）

通配符与正则表达式见后文[正则表达式](#正则表达式) 。

## 控制符

[echo输出](#echo输出)命令中使用`-e`启用控制符

注意：退格键\b并不会在内容中删除\b前面一个字符，它**只是让光标**向前**移动**一格而已，回车键\r同理。

|    控制符    | 意义                         |
| :-------: | :------------------------- |
| \a 或 \007 | 警告声alert bell              |
|    \b     | 退格键（backspace）             |
|    \E     | 退出键（escpae）                |
|    \f     | 换页符-formfeed               |
|    \n     | 换行符-new line               |
|    \r     | 回车键（return）                |
|    \t     | 表格跳位键/制表符（tab）             |
|    \v     | 垂直表格跳位键/垂直制表符-vertical tab |
|    \c     | 取消行末换行符 cancel             |
|   \0nnn   | 八进制数(nnn表示八进制数)            |
|   \xhh    | 十六进制数(hh表示十六进制数)           |
| \e[或\033[ | 字符转义为ANSI escape code      |

###ANSI escape code

`\e[`或`\033`是CSI，全称为“控制序列引导器”（Control Sequence Introducer/Initiator），能将字符转义成[ANSI escape code](https://en.wikipedia.org/wiki/ANSI_escape_code)

#### 显示样式和颜色

写法：在样式或颜色之后要使用m，如`1m`，如果使用颜色和样式，二者以`;`分隔，只在第二个数字后写上m即可，例如：`echo -e '\e[1;35m文字文字\e[0m'` 。这些样式和颜色值是ANSI escape code中的[SGR](https://en.wikipedia.org/wiki/ANSI_escape_code#CSI_codes) ，某些SGR码支持并不广泛，以下列出常见SGR code。

- 样式：
|  样式  |  加粗  |  弱化  |  斜体  | 下划线  |  闪烁  |  反色  |  隐藏  | 删除线  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  开启  |  1   |  2   |  3   |  4   |  5   |  7   |  8   |  9   |
|  关闭  |  21  |  22  |  23  |  24  |  25  |  27  |  28  |  29  |
**0恢复默认**样式。2弱化是指显示的颜色和粗细强度等减弱，22关闭弱化即使用普通效果（normal）。21具有关闭粗体或者设置双下划线的效果，不过几乎不被支持。

此外：6/26（快速闪烁，每分钟闪烁150+次）较少被支持；10用于设置首选字体，11-19设置其他代替字体，20设置哥特体。

- 颜色
|  颜色  |  黑   |  红   |  绿   |  黄   |  蓝   |  洋红  |  青   |  白   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 前景色  |  30  |  31  |  32  |  33  |  34  |  35  |  36  |  37  |
| 背景色  |  40  |  41  |  42  |  43  |  44  |  45  |  46  |  47  |

此外：38默认的前景颜色上设置下划线    39默认的前景颜色上关闭下划线    49默认背景色

#### 光标位置和键盘控制

参看ANSI escape code中中[CSI code](https://en.wikipedia.org/wiki/ANSI_escape_code#CSI_codes)

- 光标位置

| 字符内容      | 光标位置说明         |
| :-------- | :------------- |
| \033[nA   | 上移n行           |
| \033[nB   | 下移n行           |
| \033[nC   | 右移n行           |
| \033[nD   | 左移n行           |
| \033[y;xH | 设置光标位置（第y行第x列） |
| \033[K    | 清除从光标到行尾的内容    |
| \033[s    | 保存光标位置         |
| \033[u    | 恢复光标位置         |
| \033[?25l | 隐藏光标           |
| \033[?25h | 显示光标           |
| \033[2J   | 清除屏幕           |

- 键盘控制
  - \033[0q         　关闭所有的键盘指示灯 
  - \033[1q         　设置“滚动锁定”指示灯 (Scroll Lock) 
  - \033[2q         　设置“数值锁定”指示灯 (Num Lock) 
  - \033[3q         　设置“大写锁定”指示灯 (Caps Lock) 


## 重定向

在 shell的命令执行的过程中，主要有三种输出入的状况，分别是：

1. 标准输入-键盘；代码为 0 ；或称为 stdin ；使用的方式为 `<`
2. 标准输出-显示器：代码为 1 ；或称为 stdout；使用的方式为 `1>`
3. 错误输出-显示器：代码为 2 ；或称为 stderr；使用的方式为 `2>`

| 说明                           | 命令                      |
| :--------------------------- | :---------------------- |
| 将输出重定向到 file                 | command > file          |
| 将输入重定向到 file                 | command < file          |
| 将输出以追加的方式重定向到 file           | command >> file         |
| 将文件描述符为 n 的文件重定向到 file       | n > file                |
| 将文件描述符为 n 的文件以追加的方式重定向到 file | n >> file               |
| 将输出文件 m 和 n 合并               | n >& m                  |
| 将输入文件 m 和 n 合并               | n <& m                  |
| 将开始标记和结束标记之间的内容作为输入          | << tag  [some info] tag |

如果希望执行某个命令，但又不希望在屏幕上显示输出结果:

- `command > /dev/null`   - /dev/null是一个空文件
- `command > /dev/zero`   -/dev/zero是一个无显示的无限输入文件

错误重定向相关

- `2>`      将一个标准错误输出重定向到一个文件或设备 **覆盖**（取代）原来的文件
- `2>>`    将一个标准错误输出重定向到一个文件或设备 **追加**到原来的文件
- `2>&1`    将一个**标准错误输出重定向到标准输出**
- `|&`     将一个标准错误 管道 输送 到另一个命令作为输入
- `&>>`    以**追加的方式把正确输出和错误输出都保存**到同一个文件中
- `&>`以**覆盖的方式把正确输出和错误输出都保存**到同一个文件中

## 输出输入命令

### echo输出

选项：

-  -e   启用[控制符](#控制符)转换
-  -E  关闭[控制符](#控制符)转换
-  -n  取消行末换行符（同[控制符](#控制符)中`\c` ）

输出的内容最好加上引号，否则在某些情况下会出问题（如使用空格、控制符号等的时候）。
```shell
echo a  #输出test
echo a\nb    #输出anb
echo -e "a\nb"    #输出a (换行) b
```

### printf输出

printf 命令模仿 C 程序库（library）里的 printf() 程序，使用printf的脚本比使用echo移植性好。

**默认printf不会像 echo 在输出内容尾部自动添加换行符**，需要手动添加 `\n`。

```shell
$ printf "Hello, Shell\n"
Hello, Shell
```

printf可是使用格式化字符串：`printf format-string [arguments...]`

格式化

参数：

- format-string： 为格式控制字符串
- arguments：为参数列表。

例如脚本内容：

```shell
#!/bin/sh
printf "%-10s %-8s %-4s\n" 姓名 性别 身高
printf "%-10s %-8s %-4.2f\n" 人甲 男 177.7 
printf "%-10s %-8s %-4.2f\n" 人乙 女 168.8 
```

将输出：

```shell
姓名     性别   身高
人甲     男      177.7
人乙     女      168.8
```

### read输入

选项：

- -p   提示信息
- -t    等待时间（单位：秒）
- -d   持续读取直到读入定界符（delimiter）为止
- -r    不允许反斜杠转义任何字符
- -n   指定接收输入的字符数
- -s    不显示输入的数据，用于机密信息的输入（如密码）

```shell
read -p "please input username:"
read -s -p "please input password:"
read -p "请输入名字：" name  #将用户的输入内容赋值给name变量
#使用-d -r 将多行内容存到一个变量中
read -d -r '' msg << TIP
You should reboot system after installation.\n
Good Luck!\n
TIP
echo $msg    #将会输出那两行提示内容 TIP是界定符 两个TIP间的内容被存到msg变量中
```

# 变量

## 基本使用

- 定义变量：直接写出变量名并对其赋值   `var1=123`

  - 赋值符号`=`两边不能有空格
  - 变量名只能包括字母数字和下划线，并变量名不能以数字开头
  - 如果值之间有空格要使用引号（[基本特殊符号](#基本特殊符号)中单双引号的区别）引起来  `var2="hell shell"`

- 调用变量：需使用`$`或`${}`符号  `$var1`或者`${var1}`  无大括号是简写方法

  必须使用`{}`的情况：

  - 如果变量后面跟一个**非小写字符串、数字或下划线**   `${var}_1`
  - [位置参数变量](#位置参数变量)中**第10个及以后的参数的写法**
  - 避免变量混淆    例如`${var}test`和`$vartest`

- 删除变量：使用`uset`    `unset $var1 `

Shell函数的变量**默认是全局变量**（无论这个变量是在什么位置），可以被使用`local`关键字定义局部变量，其作用域局限于函数内。

## 变量分类

`set`可以查询所有已经存在的变量，`set name`查找名为name的变量

- **用户自定义**变量
- 环境变量：保存和系统环境相关的数据；对系统生效的环境变量名和变量作用是固定的。`env`可查询当前环境变量。
- 预定义变量：shell中（如bash中）已经定义好的变量，变量名不能自定义，变量作用固定。
  - 位置参数变量：向脚本中传递参数或数据，变量名不能自定义，变量作用固定。

---

### 环境变量
主要的几个环境变量配置文件：

- /etc/profie
- /etc/profile.d/*
- ~/.bash_profile
- ~/.bashrc
- /etc/bashrc

配置文件修改后立即生效，使用source，示例

```shell
source ~/.bashrc
#或者
. ~/.bashrc
```

#### 登录提示信息

- /etc/issue显示**本地登录**提示信息

  | 转义符  | 说明    |
  | ---- | ----- |
  | \d   | 日期    |
  | \t   | 时间    |
  | \l   | 终端号   |
  | \u   | 用户序列号 |
  | \m   | 硬件架构  |
  | \n   | 主机名   |
  | \o   | 域名    |
  | \r   | 内核版本  |
  | \s   | 系统名称  |

- /etc/issue.net：**远程登录**提示信息

登录成功前显示（连接上服务器后立即显示）。需要在/etc/ssh/ssh_config配置文件中有`Banner /etc/issue.net`。不支持转义字符。

- /etc/motd：登录成功后显示

### 预定义变量

| $?   | 最后一次执行的命令的返回状态（0-执行正确，1-执行错误） |
| ---- | ----------------------------- |
| $$   | 当前进程号（PID）                    |
| $!   | 后台运行的最后一个进程的进程号（PID）          |

#### 位置参数变量

| 位置参数变量 | 作用                                 |
| :----- | :--------------------------------- |
| $n     | n为数字，0代表命令行本身,第10个参数以上要用大括号`${10}` |
| $*     | **所有参数**，把所有参数视为一个整体               |
| $@     | **所有参数**，把所有参数区分对待                 |
| $#     | 所有参数的个数                            |

- 变量名命名规则：

  - **首个字符必须为字母**（a-z，A-Z）。
  - 中间不能有空格，可以使用下划线（_）。
  - **不能使用标点符号**。
  - 不能使用shell里的关键字（可用help命令查看保留关键字）。

- 变量定义和使用

  ```shell
  var=value    #定义变量
  echo $var    #使用变量
  ```

  - 所有变量的值实际都是字符串。
  - 定义变量时，**等号两边不能有空格**。
  - 重复定义变量，后面的赋值会覆盖前面的赋值。

## declare声明变量类型
用于变量类型声明。如不声明，变量默认类型是字符串。
选项：
- `-`    给变量设定类型属性
- `+`    取消变量的类型属性
- -a    将变量声明为**数组**型
- -i     将变量声明为**整数**型
- -x    将变量声明为**环境变量**
- -r    将变量声明为**只读**类型
- -p    **显示**指定变量的被声明的**类型**
- -f     仅显示函数

## 变量测试

| 变量置换方式        | 变量y没有设置    | 变量y为空值     | 变量           |
| ------------- | ---------- | ---------- | ------------ |
| `x=${y-新值} `  | x=新值       | x为空        | `x=$y`       |
| `x=${y:-新值}`  | x=新值       | x=新值       | `x=$y`       |
| `x=${y+新值}`   | x为空        | x=新值       | x=新值         |
| `x=${y:+新值}`  | x为空        | x为空        | x=新值         |
| `x=${y=新值}`   | x=新值 y=新值  | x为空 y值不变   | `x=$y`  y值不变 |
| `x=${y:=新值}`  | x=新值 y=新值  | x=新值 y=新值  | `x=$y`  y值不变 |
| `x=${y?新值}`   | 新值（标准错误）输出 | x值为空       | `x=$y`       |
| `x=${y:?新值} ` | 新值（标准错误）输出 | 新值（标准错误）输出 | `x=$y`       |

# 数组

Bash Shell 只支持一维数组。

- 定义数组的方式
  - 直接列出所有元素：`数组名=(元素0 元素1 ... 元素n)`， 使用空格隔开各个元素。
  - 单独对某个元素赋值：`数组名[下标]=值`

```shell
array1=(1 2 3 4 5)
array2[1]=123
array2[2]=567
```

- 读取数组信息
  - 某个数组元素：`${数组名[下标]}`
  - 所有元素：`${数组名[*]}`或`${数组名[@]}`
  - 数组长度：`${#数组名[*]}`或`${#数组名[@]}`  （比读取数组所有元素多一个`#` ）

```shell
echo ${array1[0]}
echo ${array2[*]}
echo ${#array2[*]}
```

# 运算

shell运算符包括：算数运算符、关系运算符、布尔运算符、字符串运算符和文件测试运算符。

## 算术运算符

同多数是编程语言一致，不再列出。**shell变量默认类型为字符串**，可使用以下方法进行数值运算（主要是整数运算）。

- `(())`表达式
```shell
a=1
b=2
c=$(($a+$b))  #c为3
((b+=2))  #b为4
```

- `$[]`表达式
```shell
var=1
var=$[$var+1]
echo $var
```

- `declare`命令
```shell
a=1
declare -i c = $a + 1  #声明为整数
echo c    #c为2
```

- `expr`命令


```shell
expr 100%11    #1  整数运算
expr $var1 + $var2  #注意加号两侧空格
```

此外`expr`还能操作字符串：

```shell
expr length "string"    #6  字符串长度
expr substr "this-string" 3 5    #is  在[3,5)区间查找字符串
expr index "string" s   #1  s第一次出现的位置
```

- `let`命令

```shell
let a=1+1    #a为2
let a++	   #a为3
let a-=2    #a为1
echo $a   # 1
```
## 关系运算符

**关系运算符只支持数字**，不支持字符串，除非字符串的值是数字。

`数字1 选项 数字2`根据各选项，将第一个数和第二个数对比，判断对比情况，返回true/false。

|  选项  | 说明                            |
| :--: | :---------------------------- |
| -eq  | 是否相等（equal）                   |
| -ne  | 是否不等（not equal）               |
| -gt  | 是否更大（greater than）            |
| -lt  | 是否更小（less than）               |
| -ge  | 是否大于等于（greater than or equal） |
| -le  | 是否小于等于（less than or equal）    |

## 字符串运算符

空和非空：`选项 字符串（或变量）` ；等和不等：`字符串1 选项 字符串2` ，根据各选项判断字符串情况，返回true或false。

|  选项  | 说明         |
| :--: | ---------- |
|  -z  | 字符串长度是否为0  |
|  -n  | 字符串长度是否不为0 |
| ==或= | 是否相等       |
|  !=  | 是否不相等      |

注意：判断是否相等时，在= 、==或!=的两侧一定要有空格（=两侧不加空格是赋值）。

提示：判断字符串是否为空最可靠的方法：`"x${value}" == "x"`

## 布尔运算符

非运算：`! 表达式`；与/或运算：`表达式1 选项 表达式2` ，根据各表达式情况判断，返回true或false。

- !    非运算
- -o    或运算
- -a    与运算

## 逻辑运算符

`表达式1 选项 表达式2`

- &&    逻辑与
- ||    逻辑或

## 文件测试运算符

### 文件类型

` 选项 文件名`根据各选项，判断文件的某种情况，返回true或false。

|  选项  | 说明                       |
| :--: | ------------------------ |
|  -b  | 判断文件是否存在，且是否为**块设备**文件   |
|  -c  | 判断文件是否存在，且是否为**字符设备**文件  |
|  -d  | 判断文件是否存在，且是否为**目录**文件    |
|  -e  | 判断文件是否存在                 |
|  -f  | 判断文件是否存在，且是否为**普通**文件    |
|  -L  | 判断文件是否存在，且是否为块**符号链接**文件 |
|  -p  | 判断文件是否存在，且是否为**管道**文件    |
|  -s  | 判断文件是否存在，且是否为非空          |
|  -S  | 判断文件是否存在，且是否为**套接字**文件   |

### 文件权限

`选项 文件名`根据各选项，判断某项权限的情况，返回true或false。

|  选项  | 说明                  |
| :--: | ------------------- |
|  -r  | 判断文件是否存在，且是否有读权限    |
|  -w  | 判断文件是否存在，且是否有写权限    |
|  -x  | 判断文件是否存在，且是否有执行权限   |
|  -u  | 判断文件是否存在，且是否有SUID权限 |
|  -g  | 判断文件是否存在，且是否有SGID权限 |
|  -k  | 判断文件是否存在，且是否有SBit权限 |

###　文件对比

`文件名1 选项 文件名2`根据各选项，将第一个文件和第二个文件对比，判断对比情况，返回true/false。

|  选项  | 说明                       |
| :--: | ------------------------ |
| -nt  | 判断文件修改时间是否更新             |
| -ot  | 判断文件修改时间是否更晚             |
| -ef  | 判断文件的Inode是否一致（一致则为同一文件） |

# 正则表达式

这里不详述正则表达式相关内容，具体参看正则表达式和相关工具文档。

**正则表达式与[通配符](#通配符)**：

正则表达式是**包含匹配**，用于**文件内容**匹配；通配符是**完全匹配**，多用于**文件名**匹配。

- 支持正则：grep 、cut、sort、awk、sed、uniq
- 只支持通配符不支持正则：find、cp、ls、rm

应注意shell中字符在正则表达式中的不同意义或用法：

- `$`  shell中用作变量引用的时置于变量名前的标志符号；正则中表示字符串末尾。
- `*`  通配符中可单独使用，代表任意个数字符；**正则中不能单独使用**，表示重复前面的内容任意次。
- `?`  通配符中可单独使用，代表1字符；**正则中不能单独使用**，表示重复前面的内容0次或1次。

# 测试表达式

各类参见运算符号（除算术运算）中各个运算符使用说明：[数值关系判断](#关系运算符)、[字符串运算符](#字符串判断)、[布尔运算符](#布尔值判断)、[逻辑运算符](#逻辑判断)和[文件测试运算符](#文件判断)

写法：

- 单中括号：`[ 表达式 ]`
- 双中括号：`[[ 表达式 ]]`

表达式与在中括号（`[]`或`[[ ]]`)之间也必须有空格（因为`[`和`[[`是linux内部命令，算数运算中的`$[]`不需要有空格）。

建议使用`[[ ]]`而不是`[ ] `（&&、||、<和> 操作符能够正常存在于`[[ ]]`条件判断结构中，但是如果出现在`[ ]`结构中会报错）。

- `test`关键字：`test 表达式`

# 流程控制

- **在关键字（如if）和中括号`[ ]`或`[[ ]]`之间必须要有空格** 。

## 分支

### 单分支

```shell
if [ expression ]
then
	#some codes
fi
#或者这样写
if [ expression ]; then
	#some codes
fi
```
### 双分支

```shell
if [ expression ]
then
	#some codes
else
	#some codes
fi
```
### 多分支
#### 多分支if
```shell
if [ expression ]
then
	#some codes
elif [ expression ]
then
	#some codes
else
	#some codes
fi
```
#### 多分支case
```shell
case var in
value1)
	#some codes
	;;
value2)
	#some codes
	;;
*)	#最后一个默认分支的值使用*
	#some codes
;;
esac
```
## 循环

### for循环

```shell
for var in value1 value2 value3
#for var in $("string")
#for var in $(cat testfile)
#也可以这样写，注意：shell中不能写诸如i+=1或i++
#for ((i=1;i<=100;i=i+1))
do
	#some codes
done
```

### while循环和util循环

- while循环：expression中条件为真时进行循环：

```shell
while(expression)
do
	#some codes
done
```

- until循环：**与while相反**，expression中条件为**假**时进行循环：

```shell
util expression
do
	#some codes
done
```
# 函数

函数格式：

```shell
[ function ] funname [()]{
    # action
    [return int;]
}
```

- `function`关键字可以省略
- 参数返回，可以显示加`return` 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255）

## 函数参数

通过 `$n` 的形式来获取参数的值，例如`$1`和`$2`， 当n>=10，即从第10可参数起，要以`${n}`的形式书写，如`${10}`和`{11}` 。

处理参数的特殊字符：

- `$#`    传递到脚本的参数个数
- `$*`    以一个单字符串显示所有向脚本传递的参数
- `$@`  与`$*`相同，但是使用时加引号，并在引号中返回每个参数。
  - `$-`  显示Shell使用的当前选项，与set命令功能相同。
  - `$?`  显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。
  - `$$`   脚本运行的当前进程ID号
  - `$!`  后台运行的最后一个进程的ID号

# 引用外部脚本

两种书写格式：

- `. filename `      注意点号`.`和文件名中间有一空格
- `source filename`    （如` source .test.sh` ）

**注：**被包含的文件可以没有可执行权限。